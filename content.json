[
    {
        "question": "I have a basic dict as follows:\nsample = {}\nsample['title'] = \"String\"\nsample['somedate'] = somedatetimehere\n\nWhen I try to do jsonify(sample) I get:\n\nTypeError: datetime.datetime(2012, 8, 8, 21, 46, 24, 862000) is not JSON serializable\n\nWhat can I do such that my dictionary sample can overcome the error above?\nNote: Though it may not be relevant, the dictionaries are generated from the retrieval of records out of mongodb where when I print out str(sample['somedate']), the output is 2012-08-08 21:46:24.862000."
    },
    {
        "answer": "My quick & dirty JSON dump that eats dates and everything:\njson.dumps(my_dictionary, indent=4, sort_keys=True, default=str)\n\n\ndefault is a function applied to objects that aren't serializable.\nIn this case it's str, so it just converts everything it doesn't know to strings. Which is great for serialization but not so great when deserializing (hence the \"quick & dirty\") as anything might have been string-ified without warning, e.g. a function or numpy array."
    },
    {
        "answer": "Building on other answers, a simple solution based on a specific serializer that just converts datetime.datetime and datetime.date objects to strings.\nfrom datetime import date, datetime\n\ndef json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n\n    if isinstance(obj, (datetime, date)):\n        return obj.isoformat()\n    raise TypeError (\"Type %s not serializable\" % type(obj))\n\nAs seen, the code just checks to find out if object is of class datetime.datetime or datetime.date, and then uses .isoformat() to produce a serialized version of it, according to ISO 8601 format, YYYY-MM-DDTHH:MM:SS (which is easily decoded by JavaScript). If more complex serialized representations are sought, other code could be used instead of str() (see other answers to this question for examples). The code ends by raising an exception, to deal with the case it is called with a non-serializable type.\nThis json_serial function can be used as follows:\nfrom datetime import datetime\nfrom json import dumps\n\nprint dumps(datetime.now(), default=json_serial)\n\nThe details about how the default parameter to json.dumps works can be found in Section Basic Usage of the json module documentation."
    },
    {
        "answer": "Updated for 2018\nThe original answer accommodated the way MongoDB \"date\" fields were represented as:\n{\"$date\": 1506816000000}\nIf you want a generic Python solution for serializing datetime to json, check out @jjmontes' answer for a quick solution which requires no dependencies.\n\nAs you are using mongoengine (per comments) and pymongo is a dependency, pymongo has built-in utilities to help with json serialization:\nhttp://api.mongodb.org/python/1.10.1/api/bson/json_util.html\nExample usage (serialization):\nfrom bson import json_util\nimport json\n\njson.dumps(anObject, default=json_util.default)\n\nExample usage (deserialization):\njson.loads(aJsonString, object_hook=json_util.object_hook)\n\n\nDjango\nDjango provides a native DjangoJSONEncoder serializer that deals with this kind of properly.\nSee https://docs.djangoproject.com/en/dev/topics/serialization/#djangojsonencoder\nfrom django.core.serializers.json import DjangoJSONEncoder\n\nreturn json.dumps(\n  item,\n  sort_keys=True,\n  indent=1,\n  cls=DjangoJSONEncoder\n)\n\nOne difference I've noticed between DjangoJSONEncoder and using a custom default like this:\nimport datetime\nimport json\n\ndef default(o):\n    if isinstance(o, (datetime.date, datetime.datetime)):\n        return o.isoformat()\n\nreturn json.dumps(\n  item,\n  sort_keys=True,\n  indent=1,\n  default=default\n)\n\nIs that Django strips a bit of the data:\n \"last_login\": \"2018-08-03T10:51:42.990\", # DjangoJSONEncoder \n \"last_login\": \"2018-08-03T10:51:42.990239\", # default\n\nSo, you may need to be careful about that in some cases."
    },
    {
        "answer": "I have just encountered this problem and my solution is to subclass json.JSONEncoder:\nfrom datetime import datetime\nimport json\n\nclass DateTimeEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, datetime):\n            return o.isoformat()\n\n        return json.JSONEncoder.default(self, o)\n\nIn your call do something like: json.dumps(yourobj, cls=DateTimeEncoder) The .isoformat() I got from one of the answers above."
    },
    {
        "answer": "Convert the date to a string\nsample['somedate'] = str( datetime.utcnow() )"
    },
    {
        "answer": "For others who do not need or want to use the pymongo library for this, you can achieve datetime JSON conversion easily with this small snippet:\ndef default(obj):\n    \"\"\"Default JSON serializer.\"\"\"\n    import calendar, datetime\n\n    if isinstance(obj, datetime.datetime):\n        if obj.utcoffset() is not None:\n            obj = obj - obj.utcoffset()\n        millis = int(\n            calendar.timegm(obj.timetuple()) * 1000 +\n            obj.microsecond / 1000\n        )\n        return millis\n    raise TypeError('Not sure how to serialize %s' % (obj,))\n\nThen use it like so:\nimport datetime, json\nprint json.dumps(datetime.datetime.now(), default=default)\n\nOutput:\n'1365091796124'"
    },
    {
        "answer": "Here is my solution:\nimport json\n\nclass DatetimeEncoder(json.JSONEncoder):\n    def default(self, obj):\n        try:\n            return super().default(obj)\n        except TypeError:\n            return str(obj)\n\nThen you can use it like that:\njson.dumps(dictionary, cls=DatetimeEncoder)"
    },
    {
        "answer": "If you are using Python 3.7, then the best solution is using\ndatetime.isoformat() and\ndatetime.fromisoformat(); they work with both naive and\naware datetime objects:\n#!/usr/bin/env python3.7\n\nfrom datetime import datetime\nfrom datetime import timezone\nfrom datetime import timedelta\nimport json\n\ndef default(obj):\n    if isinstance(obj, datetime):\n        return { '_isoformat': obj.isoformat() }\n    raise TypeError('...')\n\ndef object_hook(obj):\n    _isoformat = obj.get('_isoformat')\n    if _isoformat is not None:\n        return datetime.fromisoformat(_isoformat)\n    return obj\n\nif __name__ == '__main__':\n    #d = { 'now': datetime(2000, 1, 1) }\n    d = { 'now': datetime(2000, 1, 1, tzinfo=timezone(timedelta(hours=-8))) }\n    s = json.dumps(d, default=default)\n    print(s)\n    print(d == json.loads(s, object_hook=object_hook))\n\noutput:\n{\"now\": {\"_isoformat\": \"2000-01-01T00:00:00-08:00\"}}\nTrue\n\nIf you are using Python 3.6 or below, and you only care about the time value (not\nthe timezone), then you can use datetime.timestamp() and\ndatetime.fromtimestamp() instead;\nIf you are using Python 3.6 or below, and you do care about the timezone, then\nyou can get it via datetime.tzinfo, but you have to serialize this field\nby yourself; the easiest way to do this is to add another field _tzinfo in the\nserialized object;\nFinally, beware of precisions in all these examples;"
    },
    {
        "answer": "You should apply the .strftime() method on a datetime.datetime object to make it a string.\nHere's an example:\nfrom datetime import datetime\n\ntime_dict = {'time': datetime.now().strftime('%Y-%m-%dT%H:%M:%S')}\nsample_dict = {'a': 1, 'b': 2}\nsample_dict.update(time_dict)\nsample_dict\n\nOutput:\nOut[0]: {'a': 1, 'b': 2, 'time': '2017-10-31T15:16:30'}\n\n\n[UPDATE]:\nIn Python 3.6 or later, you can simply use the .isoformat() method:\nfrom datetime import datetime\n\ndatetime.now().isoformat()"
    },
    {
        "answer": "The json.dumps method can accept an optional parameter called default which is expected to be a function. Every time JSON tries to convert a value it does not know how to convert, it will call the function we passed to it. The function will receive the object in question, and it is expected to return the JSON representation of the object.\ndef myconverter(o):\n  if isinstance(o, datetime.datetime):\n    return o.__str__()\n\nprint(json.dumps(d, default = myconverter))"
    },
    {
        "answer": "I have an application with a similar issue; my approach was to JSONize the datetime value as a 6-item list (year, month, day, hour, minutes, seconds); you could go to microseconds as a 7-item list, but I had no need to:\nclass DateTimeEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            encoded_object = list(obj.timetuple())[0:6]\n        else:\n            encoded_object =json.JSONEncoder.default(self, obj)\n        return encoded_object\n\nsample = {}\nsample['title'] = \"String\"\nsample['somedate'] = datetime.datetime.now()\n\nprint sample\nprint json.dumps(sample, cls=DateTimeEncoder)\n\nproduces:\n{'somedate': datetime.datetime(2013, 8, 1, 16, 22, 45, 890000), 'title': 'String'}\n{\"somedate\": [2013, 8, 1, 16, 22, 45], \"title\": \"String\"}"
    },
    {
        "answer": "My solution (with less verbosity, I think):\ndef default(o):\n    if type(o) is datetime.date or type(o) is datetime.datetime:\n        return o.isoformat()\n\ndef jsondumps(o):\n    return json.dumps(o, default=default)\n\nThen use jsondumps instead of json.dumps. It will print:\n>>> jsondumps({'today': datetime.date.today()})\n'{\"today\": \"2013-07-30\"}'\n\nI you want, later you can add other special cases to this with a simple twist of the default method. Example:  \ndef default(o):\n    if type(o) is datetime.date or type(o) is datetime.datetime:\n        return o.isoformat()\n    if type(o) is decimal.Decimal:\n        return float(o)"
    },
    {
        "answer": "This question repeats time and time again—a simple way to patch the json module such that serialization would support datetime.\nimport json\nimport datetime\n\njson.JSONEncoder.default = lambda self,obj: (obj.isoformat() if isinstance(obj, datetime.datetime) else None)\n\nThen use JSON serialization as you always do, this time with datetime being serialized as isoformat.\njson.dumps({'created':datetime.datetime.now()})\n\nResulting in: '{\"created\": \"2015-08-26T14:21:31.853855\"}'\nSee more details and some words of caution at:\nStack Overflow: JSON datetime between Python and JavaScript"
    },
    {
        "answer": "Here is a simple solution to over come \"datetime not JSON serializable\"\nproblem. \nenco = lambda obj: (\n    obj.isoformat()\n    if isinstance(obj, datetime.datetime)\n    or isinstance(obj, datetime.date)\n    else None\n)\n\njson.dumps({'date': datetime.datetime.now()}, default=enco)\n\nOutput:-> {\"date\": \"2015-12-16T04:48:20.024609\"}"
    },
    {
        "answer": "You have to supply a custom encoder class with the cls parameter of json.dumps. To quote from the documentation:\n>>> import json\n>>> class ComplexEncoder(json.JSONEncoder):\n...     def default(self, obj):\n...         if isinstance(obj, complex):\n...             return [obj.real, obj.imag]\n...         return json.JSONEncoder.default(self, obj)\n...\n>>> dumps(2 + 1j, cls=ComplexEncoder)\n'[2.0, 1.0]'\n>>> ComplexEncoder().encode(2 + 1j)\n'[2.0, 1.0]'\n>>> list(ComplexEncoder().iterencode(2 + 1j))\n['[', '2.0', ', ', '1.0', ']']\n\nThis uses complex numbers as the example, but you can just as easily create a class to encode dates (except I think JSON is a little fuzzy about dates)."
    },
    {
        "answer": "I usually use orjson. Not only because of its tremendous performance, but also for its great (RFC-3339 compliant) support of datetime:\nimport orjson # via pip3 install orjson\nfrom datetime import datetime\n\ndata = {\"created_at\": datetime(2022, 3, 1)}\n\norjson.dumps(data) # returns b'{\"created_at\":\"2022-03-01T00:00:00\"}'\n\nIf you would like to use datetime.datetime objects without a tzinfo as UTC you can add the related option:\norjson.dumps(data, option=orjson.OPT_NAIVE_UTC) # returns b'{\"created_at\":\"2022-03-01T00:00:00+00:00\"}'"
    },
    {
        "answer": "Actually it is quite simple.\nIf you need to often serialize dates, then work with them as strings. You can easily convert them back as datetime objects if needed.\nIf you need to work mostly as datetime objects, then convert them as strings before serializing. \nimport json, datetime\n\ndate = str(datetime.datetime.now())\nprint(json.dumps(date))\n\"2018-12-01 15:44:34.409085\"\nprint(type(date))\n<class 'str'>\n\ndatetime_obj = datetime.datetime.strptime(date, '%Y-%m-%d %H:%M:%S.%f')\nprint(datetime_obj)\n2018-12-01 15:44:34.409085\nprint(type(datetime_obj))\n<class 'datetime.datetime'>\n\nAs you can see, the output is the same in both cases. Only the type is different."
    },
    {
        "answer": "The simplest way to do this is to change the part of the dict that is in datetime format to isoformat. That value will effectively be a string in isoformat which json is OK with.\nv_dict = version.dict()\nv_dict['created_at'] = v_dict['created_at'].isoformat()"
    },
    {
        "answer": "Try this one with an example to parse it:\n#!/usr/bin/env python\n\nimport datetime\nimport json\n\nimport dateutil.parser  # pip install python-dateutil\n\n\nclass JSONEncoder(json.JSONEncoder):\n\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            return obj.isoformat()\n        return super(JSONEncoder, self).default(obj)\n\n\ndef test():\n    dts = [\n        datetime.datetime.now(),\n        datetime.datetime.now(datetime.timezone(-datetime.timedelta(hours=4))),\n        datetime.datetime.utcnow(),\n        datetime.datetime.now(datetime.timezone.utc),\n    ]\n    for dt in dts:\n        dt_isoformat = json.loads(json.dumps(dt, cls=JSONEncoder))\n        dt_parsed = dateutil.parser.parse(dt_isoformat)\n        assert dt == dt_parsed\n        print(f'{dt}, {dt_isoformat}, {dt_parsed}')\n        # 2018-07-22 02:22:42.910637, 2018-07-22T02:22:42.910637, 2018-07-22 02:22:42.910637\n        # 2018-07-22 02:22:42.910643-04:00, 2018-07-22T02:22:42.910643-04:00, 2018-07-22 02:22:42.910643-04:00\n        # 2018-07-22 06:22:42.910645, 2018-07-22T06:22:42.910645, 2018-07-22 06:22:42.910645\n        # 2018-07-22 06:22:42.910646+00:00, 2018-07-22T06:22:42.910646+00:00, 2018-07-22 06:22:42.910646+00:00\n\n\nif __name__ == '__main__':\n    test()"
    },
    {
        "answer": "If you are working with Django models you can directly pass encoder=DjangoJSONEncoder to the field constructor. It will work like a charm.\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.db import models\nfrom django.utils.timezone import now\n\n\nclass Activity(models.Model):\n    diff = models.JSONField(null=True, blank=True, encoder=DjangoJSONEncoder)\n\n\ndiff = {\n    \"a\": 1,\n    \"b\": \"BB\",\n    \"c\": now()\n}\n\nActivity.objects.create(diff=diff)"
    },
    {
        "answer": "Generally there are several ways to serialize datetimes, like:\n\nISO 8601 string, short and can include timezone info, e.g., jgbarah's answer\nTimestamp (timezone data is lost), e.g. JayTaylor's answer\nDictionary of  properties (including timezone).\n\nIf you're okay with the last way, the json_tricks package handles dates, times and datetimes including timezones.\nfrom datetime import datetime\nfrom json_tricks import dumps\nfoo = {'title': 'String', 'datetime': datetime(2012, 8, 8, 21, 46, 24, 862000)}\ndumps(foo)\n\nwhich gives:\n{\"title\": \"String\", \"datetime\": {\"__datetime__\": null, \"year\": 2012, \"month\": 8, \"day\": 8, \"hour\": 21, \"minute\": 46, \"second\": 24, \"microsecond\": 862000}}\n\nSo all you need to do is\n`pip install json_tricks`\n\nand then import from json_tricks instead of json.\nThe advantage of not storing it as a single string, int or float comes when decoding: if you encounter just a string or especially int or float, you need to know something about the data to know if it's a datetime. As a dict, you can store metadata so it can be decoded automatically, which is what json_tricks does for you. It's also easily editable for humans.\nDisclaimer: it's made by me. Because I had the same problem."
    },
    {
        "answer": "If you are using the result in a view be sure to return a proper response. According to the API, jsonify does the following:\n\nCreates a Response with the JSON representation of the given arguments\n  with an application/json mimetype.\n\nTo mimic this behavior with json.dumps you have to add a few extra lines of code.\nresponse = make_response(dumps(sample, cls=CustomEncoder))\nresponse.headers['Content-Type'] = 'application/json'\nresponse.headers['mimetype'] = 'application/json'\nreturn response\n\nYou should also return a dict to fully replicate jsonify's response. So, the entire file will look like this\nfrom flask import make_response\nfrom json import JSONEncoder, dumps\n\n\nclass CustomEncoder(JSONEncoder):\n    def default(self, obj):\n        if set(['quantize', 'year']).intersection(dir(obj)):\n            return str(obj)\n        elif hasattr(obj, 'next'):\n            return list(obj)\n        return JSONEncoder.default(self, obj)\n\n@app.route('/get_reps/', methods=['GET'])\ndef get_reps():\n    sample = ['some text', <datetime object>, 123]\n    response = make_response(dumps({'result': sample}, cls=CustomEncoder))\n    response.headers['Content-Type'] = 'application/json'\n    response.headers['mimetype'] = 'application/json'\n    return response"
    },
    {
        "answer": "My solution ...\nfrom datetime import datetime\nimport json\n\nfrom pytz import timezone\nimport pytz\n\n\ndef json_dt_serializer(obj):\n    \"\"\"JSON serializer, by macm.\n    \"\"\"\n    rsp = dict()\n    if isinstance(obj, datetime):\n        rsp['day'] = obj.day\n        rsp['hour'] = obj.hour\n        rsp['microsecond'] = obj.microsecond\n        rsp['minute'] = obj.minute\n        rsp['month'] = obj.month\n        rsp['second'] = obj.second\n        rsp['year'] = obj.year\n        rsp['tzinfo'] = str(obj.tzinfo)\n        return rsp\n    raise TypeError(\"Type not serializable\")\n\n\ndef json_dt_deserialize(obj):\n    \"\"\"JSON deserialize from json_dt_serializer, by macm.\n    \"\"\"\n    if isinstance(obj, str):\n        obj = json.loads(obj)\n    tzone = timezone(obj['tzinfo'])\n    tmp_dt = datetime(obj['year'],\n                      obj['month'],\n                      obj['day'],\n                      hour=obj['hour'],\n                      minute=obj['minute'],\n                      second=obj['second'],\n                      microsecond=obj['microsecond'])\n    loc_dt = tzone.localize(tmp_dt)\n    deserialize = loc_dt.astimezone(tzone)\n    return deserialize    \n\nOk, now some tests.\n# Tests\nnow = datetime.now(pytz.utc)\n\n# Using this solution\nrsp = json_dt_serializer(now)\ntmp = json_dt_deserialize(rsp)\nassert tmp == now\nassert isinstance(tmp, datetime) == True\nassert isinstance(now, datetime) == True\n\n# using default from json.dumps\ntmp = json.dumps(datetime.now(pytz.utc), default=json_dt_serializer)\nrsp = json_dt_deserialize(tmp)\nassert isinstance(rsp, datetime) == True\n\n# Lets try another timezone\neastern = timezone('US/Eastern')\nnow = datetime.now(eastern)\nrsp = json_dt_serializer(now)\ntmp = json_dt_deserialize(rsp)\n\nprint(tmp)\n# 2015-10-22 09:18:33.169302-04:00\n\nprint(now)\n# 2015-10-22 09:18:33.169302-04:00\n\n# Wow, Works!\nassert tmp == now"
    },
    {
        "answer": "Convert the date  to  string\ndate = str(datetime.datetime(somedatetimehere))"
    },
    {
        "answer": "Here is my full solution for converting datetime to JSON and back...\nimport calendar, datetime, json\n\ndef outputJSON(obj):\n    \"\"\"Default JSON serializer.\"\"\"\n\n    if isinstance(obj, datetime.datetime):\n        if obj.utcoffset() is not None:\n            obj = obj - obj.utcoffset()\n\n        return obj.strftime('%Y-%m-%d %H:%M:%S.%f')\n    return str(obj)\n\ndef inputJSON(obj):\n    newDic = {}\n\n    for key in obj:\n        try:\n            if float(key) == int(float(key)):\n                newKey = int(key)\n            else:\n                newKey = float(key)\n\n            newDic[newKey] = obj[key]\n            continue\n        except ValueError:\n            pass\n\n        try:\n            newDic[str(key)] = datetime.datetime.strptime(obj[key], '%Y-%m-%d %H:%M:%S.%f')\n            continue\n        except TypeError:\n            pass\n\n        newDic[str(key)] = obj[key]\n\n    return newDic\n\nx = {'Date': datetime.datetime.utcnow(), 34: 89.9, 12.3: 90, 45: 67, 'Extra': 6}\n\nprint x\n\nwith open('my_dict.json', 'w') as fp:\n    json.dump(x, fp, default=outputJSON)\n\nwith open('my_dict.json') as f:\n    my_dict = json.load(f, object_hook=inputJSON)\n\nprint my_dict\n\nOutput\n{'Date': datetime.datetime(2013, 11, 8, 2, 30, 56, 479727), 34: 89.9, 45: 67, 12.3: 90, 'Extra': 6}\n{'Date': datetime.datetime(2013, 11, 8, 2, 30, 56, 479727), 34: 89.9, 45: 67, 12.3: 90, 'Extra': 6}\n\nJSON File\n{\"Date\": \"2013-11-08 02:30:56.479727\", \"34\": 89.9, \"45\": 67, \"12.3\": 90, \"Extra\": 6}\n\nThis has enabled me to import and export strings, ints, floats and datetime objects.\nIt shouldn't be to hard to extend for other types."
    },
    {
        "answer": "As per the jjmontes' answer, I have used the following approach.\nFor Flask and flask-restful users\n# Get JSON string\njsonStr = json.dumps(my_dictionary, indent=1, sort_keys=True, default=str)\n# Then convert the JSON string to a JSON object\nreturn json.loads(jsonStr)"
    },
    {
        "answer": "I got the same error message while writing the serialize decorator inside a Class  with sqlalchemy. So instead of :\nClass Puppy(Base):\n    ...\n    @property\n    def serialize(self):\n        return { 'id':self.id,\n                 'date_birth':self.date_birth,\n                  ...\n                }\n\nI  simply borrowed jgbarah's idea of using isoformat() and appended the original value with isoformat(), so that it now looks like:\n                  ...\n                 'date_birth':self.date_birth.isoformat(),\n                  ..."
    },
    {
        "answer": "A quick fix if you want your own formatting\nfor key,val in sample.items():\n    if isinstance(val, datetime):\n        sample[key] = '{:%Y-%m-%d %H:%M:%S}'.format(val) #you can add different formating here\njson.dumps(sample)"
    },
    {
        "answer": "I had encountered the same problem when externalizing a Django model object to dump as JSON.\nHere is how you can solve it.\ndef externalize(model_obj):\n  keys = model_obj._meta.get_all_field_names()\n  data = {}\n  for key in keys:\n    if key == 'date_time':\n      date_time_obj = getattr(model_obj, key)\n      data[key] = date_time_obj.strftime(\"%A %d. %B %Y\")\n    else:\n      data[key] = getattr(model_obj, key)\n  return data"
    },
    {
        "answer": "I faced this issue today, I found something called pickle. It's a built-in library for serializing Python objects and also load it from a pickle file.\nThe only difference I found between pickle and json is pickle file is a binary file, whereas json is a usual text file.\nAnd it doesn't cause any issues with datetime objects."
    }
]